<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space War - Enhanced</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Malgun Gothic', sans-serif;
            background: #000; color: #fff; overflow: hidden;
        }
        #ui {
            position: fixed; top: 0; left: 0; width: 100%;
            padding: 20px; pointer-events: none; z-index: 10;
        }
        .stat-bar {
            background: rgba(0,0,0,0.8); border: 2px solid #00ffff;
            border-radius: 10px; padding: 10px;
            display: inline-block; margin-right: 20px;
            box-shadow: 0 0 15px rgba(0,255,255,0.3);
        }
        .stat-label { color: #00ffff; font-size: 14px; margin-bottom: 5px; }
        .bar {
            width: 200px; height: 20px; background: #333;
            border-radius: 5px; overflow: hidden; border: 1px solid #666;
        }
        .bar-fill {
            height: 100%; transition: width 0.3s;
            background: linear-gradient(90deg, #00ff00, #00cc00);
            box-shadow: 0 0 10px rgba(0,255,0,0.5);
        }
        .exp-bar .bar-fill {
            background: linear-gradient(90deg, #ffff00, #ff9900);
            box-shadow: 0 0 10px rgba(255,255,0,0.5);
        }
        #levelUpModal {
            position: fixed; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.95); border: 3px solid #00ffff;
            border-radius: 15px; padding: 30px; display: none;
            z-index: 100; max-width: 1000px; pointer-events: auto;
            box-shadow: 0 0 40px rgba(0,255,255,0.6);
        }
        .upgrade-grid {
            display: grid; grid-template-columns: repeat(5, 1fr);
            gap: 15px; margin-top: 20px;
        }
        .upgrade-card {
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            border: 2px solid #00ffff; border-radius: 10px;
            padding: 15px; cursor: pointer; transition: all 0.3s;
        }
        .upgrade-card:hover {
            transform: scale(1.05); border-color: #00ff00;
            box-shadow: 0 0 20px rgba(0,255,255,0.5);
        }
        .upgrade-icon { font-size: 32px; margin-bottom: 8px; }
        .upgrade-name {
            color: #00ffff; font-size: 15px;
            font-weight: bold; margin-bottom: 8px;
        }
        .upgrade-desc { color: #aaa; font-size: 12px; }
        .level-display { color: #ffff00; font-size: 13px; margin-top: 8px; }
        #gameOver {
            position: fixed; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.95); border: 3px solid #ff0000;
            border-radius: 15px; padding: 40px; display: none;
            z-index: 100; text-align: center;
            box-shadow: 0 0 40px rgba(255,0,0,0.6);
        }
        .btn {
            background: linear-gradient(135deg, #00ffff, #0099ff);
            border: none; color: #000; padding: 15px 30px;
            font-size: 18px; font-weight: bold; border-radius: 10px;
            cursor: pointer; margin: 10px; transition: all 0.3s;
        }
        .btn:hover {
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(0,255,255,0.8);
        }
        #stats {
            position: fixed; top: 80px; left: 20px;
            background: rgba(0,0,0,0.8); border: 2px solid #00ffff;
            border-radius: 10px; padding: 15px; font-size: 14px; color: #0ff;
            box-shadow: 0 0 15px rgba(0,255,255,0.3);
        }
    </style>
</head>
<body>
    <div id="game-container"></div>
    
    <div id="ui">
        <div class="stat-bar">
            <div class="stat-label">HP: <span id="hpText">150/150</span></div>
            <div class="bar"><div class="bar-fill" id="hpBar" style="width: 100%"></div></div>
        </div>
        <div class="stat-bar exp-bar">
            <div class="stat-label">ê²½í—˜ì¹˜: <span id="expText">0/100</span></div>
            <div class="bar"><div class="bar-fill" id="expBar" style="width: 0%"></div></div>
        </div>
    </div>
    
    <div id="stats">
        <div>ë ˆë²¨: <span id="levelText">1</span></div>
        <div>ì‹œê°„: <span id="timeText">00:00</span></div>
        <div>ì²˜ì¹˜: <span id="killText">0</span></div>
    </div>
    
    <div id="levelUpModal">
        <h2 style="color: #00ffff; text-align: center; margin-bottom: 20px;">â¬†ï¸ ë ˆë²¨ ì—…! ì—…ê·¸ë ˆì´ë“œ ì„ íƒ</h2>
        <div class="upgrade-grid" id="upgradeOptions"></div>
    </div>
    
    <div id="gameOver">
        <h1 style="color: #ff0000; margin-bottom: 20px;">ğŸ’¥ ì „í•¨ íŒŒê´´!</h1>
        <div style="font-size: 24px; margin-bottom: 20px;">
            <div>ìƒì¡´ ì‹œê°„: <span id="finalTime" style="color: #ffff00;">00:00</span></div>
            <div>ì´ ì²˜ì¹˜: <span id="finalKills" style="color: #00ff00;">0</span></div>
            <div>ìµœì¢… ë ˆë²¨: <span id="finalLevel" style="color: #00ffff;">1</span></div>
        </div>
        <button class="btn" onclick="location.reload()">ğŸ”„ ë‹¤ì‹œ ì‹œì‘</button>
    </div>

    <script>
        // === Phaser ì„¤ì • ===
        const config = {
            type: Phaser.WEBGL,
            width: window.innerWidth,
            height: window.innerHeight,
            parent: 'game-container',
            backgroundColor: '#1a1a2e',
            scene: {
                preload: preload,
                create: create,
                update: update
            }
        };

        const phaserGame = new Phaser.Game(config);
        let phaserScene, graphics;

        // ì¿¼í„°ë·° ë³€í™˜ (ì›ë˜ ì½”ë“œ ê·¸ëŒ€ë¡œ)
        const iso = {
            toScreen: function(worldX, worldY) {
                const rotX = (worldX - worldY) * 0.707;
                const rotY = (worldX + worldY) * 0.707;
                return { x: rotX, y: rotY * 0.5 };
            }
        };
        
        // ê²Œì„ ìƒíƒœ (ì›ë˜ ì½”ë“œ ê·¸ëŒ€ë¡œ)
        const game = {
            running: true,
            paused: false,
            time: 0,
            kills: 0,
            camera: { x: 0, y: 0 },
            player: {
                x: 0, y: 0, size: 20,
                hp: 150, maxHp: 150,
                level: 1, exp: 0, expToNext: 100
            },
            weapons: [{ type: 'laser', lastShot: 0 }],
            enemies: [],
            projectiles: [],
            particles: []
        };
        
        // ë¬´ê¸° ì •ì˜ (ì›ë˜ ì½”ë“œ ê·¸ëŒ€ë¡œ)
        const weaponTypes = {
            laser: {
                name: 'ë ˆì´ì € í¬', icon: 'ğŸ”«', desc: 'ì „ë°©ìœ„ ë ˆì´ì €',
                damage: 10, cooldown: 250, level: 1, maxLevel: 8,
                shoot: function(player) {
                    const count = 2 + this.level;
                    for (let i = 0; i < count; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        game.projectiles.push({
                            x: player.x, y: player.y, z: 10,
                            vx: Math.cos(angle) * 200,
                            vy: Math.sin(angle) * 200,
                            size: 6,
                            damage: this.damage * (1 + this.level * 0.5),
                            color: '#00ffff',
                            type: 'laser'
                        });
                    }
                }
            },
            missile: {
                name: 'ìœ ë„ ë¯¸ì‚¬ì¼', icon: 'ğŸš€', desc: 'ì  ì¶”ì  ë¯¸ì‚¬ì¼',
                damage: 25, cooldown: 1000, level: 0, maxLevel: 6,
                shoot: function(player) {
                    if (game.enemies.length === 0) return;
                    const count = 1 + Math.floor(this.level / 2);
                    for (let i = 0; i < count; i++) {
                        const target = game.enemies[i % game.enemies.length];
                        game.projectiles.push({
                            x: player.x, y: player.y, z: 15,
                            vx: 0, vy: 0, size: 8,
                            damage: this.damage * (1 + this.level * 0.4),
                            color: '#ff6600', type: 'missile',
                            target: target, speed: 150
                        });
                    }
                }
            },
            plasma: {
                name: 'í”Œë¼ì¦ˆë§ˆ ë³¼', icon: 'ğŸ’¥', desc: 'ë°©ì‚¬í˜• í”Œë¼ì¦ˆë§ˆ',
                damage: 15, cooldown: 800, level: 0, maxLevel: 6,
                shoot: function(player) {
                    const count = 4 + this.level * 2;
                    for (let i = 0; i < count; i++) {
                        const angle = (Math.PI * 2 / count) * i;
                        game.projectiles.push({
                            x: player.x, y: player.y, z: 12,
                            vx: Math.cos(angle) * 180,
                            vy: Math.sin(angle) * 180,
                            size: 10,
                            damage: this.damage * (1 + this.level * 0.3),
                            color: '#ff00ff',
                            type: 'plasma'
                        });
                    }
                }
            },
            lightning: {
                name: 'ë²ˆê°œ ì²´ì¸', icon: 'âš¡', desc: 'ì  ê°„ ì—°ì‡„ ê³µê²©',
                damage: 20, cooldown: 1500, level: 0, maxLevel: 6,
                shoot: function(player) {
                    if (game.enemies.length === 0) return;
                    const chains = 2 + this.level;
                    let current = game.enemies[0];
                    const hit = new Set([current]);
                    
                    for (let i = 0; i < chains && current; i++) {
                        current.hp -= this.damage * (1 + this.level * 0.5);
                        createParticles(current.x, current.y, 0, '#ffff00', 15);
                        
                        let next = null;
                        let minDist = 300;
                        for (const enemy of game.enemies) {
                            if (hit.has(enemy)) continue;
                            const dist = Math.hypot(enemy.x - current.x, enemy.y - current.y);
                            if (dist < minDist) {
                                minDist = dist;
                                next = enemy;
                            }
                        }
                        if (next) hit.add(next);
                        current = next;
                    }
                }
            },
            flamethrower: {
                name: 'í™”ì—¼ë°©ì‚¬ê¸°', icon: 'ğŸ”¥', desc: 'ê·¼ê±°ë¦¬ ê´‘ì—­ í™”ì—¼',
                damage: 8, cooldown: 100, level: 0, maxLevel: 8,
                shoot: function(player) {
                    const count = 5 + this.level * 2;
                    for (let i = 0; i < count; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const speed = 120 + Math.random() * 50;
                        game.projectiles.push({
                            x: player.x, y: player.y, z: 5,
                            vx: Math.cos(angle) * speed,
                            vy: Math.sin(angle) * speed,
                            size: 8,
                            damage: this.damage * (1 + this.level * 0.3),
                            color: '#ff4500',
                            type: 'flame',
                            life: 20 + this.level * 5
                        });
                    }
                }
            },
            railgun: {
                name: 'ë ˆì¼ê±´', icon: 'ğŸ¯', desc: 'ê³ ìœ„ë ¥ ê´€í†µ ë¹”',
                damage: 50, cooldown: 2000, level: 0, maxLevel: 5,
                shoot: function(player) {
                    if (game.enemies.length === 0) return;
                    const target = game.enemies[0];
                    const dx = target.x - player.x;
                    const dy = target.y - player.y;
                    const angle = Math.atan2(dy, dx);
                    
                    game.projectiles.push({
                        x: player.x, y: player.y, z: 10,
                        vx: Math.cos(angle) * 400,
                        vy: Math.sin(angle) * 400,
                        size: 12,
                        damage: this.damage * (1 + this.level * 0.6),
                        color: '#00ff88',
                        type: 'railgun',
                        pierce: 3 + this.level
                    });
                }
            },
            bomb: {
                name: 'í­íƒ„', icon: 'ğŸ’£', desc: 'ê´‘ì—­ í­ë°œ',
                damage: 30, cooldown: 3000, level: 0, maxLevel: 5,
                shoot: function(player) {
                    if (game.enemies.length === 0) return;
                    const target = game.enemies[0];
                    game.projectiles.push({
                        x: player.x, y: player.y, z: 20,
                        vx: (target.x - player.x) * 0.3,
                        vy: (target.y - player.y) * 0.3,
                        vz: 100, size: 10,
                        damage: this.damage * (1 + this.level * 0.5),
                        color: '#ff0000',
                        type: 'bomb',
                        radius: 100 + this.level * 20
                    });
                }
            },
            drone: {
                name: 'ë“œë¡ ', icon: 'ğŸ›¸', desc: 'ìë™ ê³µê²© ë“œë¡ ',
                damage: 12, cooldown: 600, level: 0, maxLevel: 5,
                shoot: function(player) {
                    if (game.enemies.length === 0) return;
                    const count = Math.min(1 + this.level, game.enemies.length);
                    for (let i = 0; i < count; i++) {
                        const target = game.enemies[i];
                        const angle = Math.atan2(target.y - player.y, target.x - player.x);
                        game.projectiles.push({
                            x: player.x, y: player.y, z: 15,
                            vx: Math.cos(angle) * 180,
                            vy: Math.sin(angle) * 180,
                            size: 6,
                            damage: this.damage * (1 + this.level * 0.4),
                            color: '#00ccff',
                            type: 'drone'
                        });
                    }
                }
            },
            satellite: {
                name: 'ìœ„ì„± ë ˆì´ì €', icon: 'ğŸ›°ï¸', desc: 'ê¶¤ë„ ë ˆì´ì € ê³µê²©',
                damage: 40, cooldown: 2500, level: 0, maxLevel: 5,
                shoot: function(player) {
                    if (game.enemies.length === 0) return;
                    const count = 1 + Math.floor(this.level / 2);
                    for (let i = 0; i < count; i++) {
                        const target = game.enemies[i % game.enemies.length];
                        target.hp -= this.damage * (1 + this.level * 0.5);
                        createParticles(target.x, target.y, 0, '#00ffff', 20);
                    }
                }
            },
            shield: {
                name: 'ì—ë„ˆì§€ ì‹¤ë“œ', icon: 'ğŸ›¡ï¸', desc: 'ìµœëŒ€ ì²´ë ¥ +30',
                level: 0, maxLevel: 8,
                apply: function() {
                    game.player.maxHp += 30;
                    game.player.hp = Math.min(game.player.hp + 30, game.player.maxHp);
                }
            },
            regen: {
                name: 'ì¬ìƒ', icon: 'ğŸ’š', desc: 'ì²´ë ¥ íšŒë³µ +20',
                level: 0, maxLevel: 10,
                apply: function() {
                    game.player.hp = Math.min(game.player.hp + 20, game.player.maxHp);
                }
            },
            damage: {
                name: 'í™”ë ¥ ì¦ê°•', icon: 'ğŸ’ª', desc: 'ëª¨ë“  ë¬´ê¸° +10%',
                level: 0, maxLevel: 15,
                apply: function() {}
            }
        };
        
        // Phaser í•¨ìˆ˜ë“¤
        function preload() {
            phaserScene = this;
        }

        function create() {
            graphics = this.add.graphics();
        }

        let lastTime = 0;
        let enemySpawnTimer = 0;

        function update(time, delta) {
            if (!game.running) return;
            
            const timestamp = time;
            const deltaTime = Math.min(delta / 1000, 0.1);
            
            if (!game.paused) {
                game.time += deltaTime;
                
                // ë¬´ê¸° ë°œì‚¬ (ì›ë˜ ë¡œì§)
                game.weapons.forEach(weapon => {
                    const weaponData = weaponTypes[weapon.type];
                    if (timestamp - weapon.lastShot > weaponData.cooldown) {
                        weaponData.shoot(game.player);
                        weapon.lastShot = timestamp;
                    }
                });
                
                // ë°œì‚¬ì²´ ì—…ë°ì´íŠ¸ (ì›ë˜ ë¡œì§)
                game.projectiles = game.projectiles.filter(proj => {
                    if (proj.life !== undefined) {
                        proj.life--;
                        if (proj.life <= 0) return false;
                    }
                    
                    if (proj.type === 'bomb' && proj.vz !== undefined) {
                        proj.z += proj.vz * deltaTime;
                        proj.vz -= 200 * deltaTime;
                        if (proj.z <= 0) {
                            proj.z = 0;
                            game.enemies.forEach(enemy => {
                                const dist = Math.hypot(enemy.x - proj.x, enemy.y - proj.y);
                                if (dist < proj.radius) {
                                    enemy.hp -= proj.damage * (1 + (weaponTypes.damage.level * 0.1));
                                    createParticles(enemy.x, enemy.y, 0, '#ff6600', 10);
                                }
                            });
                            createParticles(proj.x, proj.y, 0, '#ff0000', 40);
                            return false;
                        }
                    }
                    
                    if (proj.type === 'missile' && proj.target) {
                        const dx = proj.target.x - proj.x;
                        const dy = proj.target.y - proj.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist > 1) {
                            proj.vx = (dx/dist) * proj.speed;
                            proj.vy = (dy/dist) * proj.speed;
                        }
                    }
                    
                    proj.x += proj.vx * deltaTime;
                    proj.y += proj.vy * deltaTime;
                    
                    const distFromPlayer = Math.hypot(proj.x, proj.y);
                    return distFromPlayer < 1500;
                });
                
                // ì  ì—…ë°ì´íŠ¸ (ì›ë˜ ë¡œì§)
                game.enemies.forEach(enemy => {
                    const dx = -enemy.x;
                    const dy = -enemy.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    
                    if (dist > 1) {
                        enemy.x += (dx/dist) * enemy.speed * deltaTime;
                        enemy.y += (dy/dist) * enemy.speed * deltaTime;
                    }
                    
                    if (dist < game.player.size + enemy.size) {
                        game.player.hp -= enemy.damage;
                        createParticles(enemy.x, enemy.y, 0, '#ff0000', 5);
                        enemy.hp = 0;
                        
                        if (game.player.hp <= 0) {
                            gameOver();
                        }
                    }
                });
                
                // ì¶©ëŒ ì²´í¬ (ì›ë˜ ë¡œì§)
                game.projectiles.forEach(proj => {
                    if (proj.type === 'bomb') return;
                    
                    game.enemies.forEach(enemy => {
                        const dx = proj.x - enemy.x;
                        const dy = proj.y - enemy.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        
                        if (dist < proj.size + enemy.size) {
                            const totalDamage = proj.damage * (1 + (weaponTypes.damage.level * 0.1));
                            enemy.hp -= totalDamage;
                            createParticles(enemy.x, enemy.y, 0, proj.color);
                            
                            if (proj.pierce) {
                                proj.pierce--;
                                if (proj.pierce <= 0) proj.x = -99999;
                            } else {
                                proj.x = -99999;
                            }
                            
                            if (enemy.hp <= 0) {
                                game.kills++;
                                game.player.exp += 10;
                                createParticles(enemy.x, enemy.y, 0, '#ffff00', 20);
                                
                                if (game.player.exp >= game.player.expToNext) {
                                    game.player.level++;
                                    game.player.exp -= game.player.expToNext;
                                    game.player.expToNext = Math.floor(game.player.expToNext * 1.2);
                                    showLevelUp();
                                }
                            }
                        }
                    });
                });
                
                game.enemies = game.enemies.filter(e => e.hp > 0);
                
                // íŒŒí‹°í´ ì—…ë°ì´íŠ¸ (ì›ë˜ ë¡œì§)
                game.particles = game.particles.filter(p => {
                    p.x += p.vx * deltaTime;
                    p.y += p.vy * deltaTime;
                    if (p.vz) {
                        p.z += p.vz * deltaTime;
                        p.vz -= 200 * deltaTime;
                        if (p.z < 0) {
                            p.z = 0;
                            p.vz = 0;
                        }
                    }
                    p.life--;
                    return p.life > 0;
                });
                
                // ì  ìŠ¤í° (ì›ë˜ ë¡œì§)
                const spawnRate = Math.max(300 - game.time * 8, 100);
                enemySpawnTimer += deltaTime * 1000;
                if (enemySpawnTimer > spawnRate) {
                    spawnEnemy();
                    enemySpawnTimer = 0;
                }
            }
            
            // ë Œë”ë§ (Phaser Graphicsë¡œ êµì²´)
            render();
            updateUI();
        }

        function render() {
            graphics.clear();
            
            const centerX = config.width / 2;
            const centerY = config.height / 2;
            
            // ê·¸ë¦¬ë“œ (ì›ë˜ ìŠ¤íƒ€ì¼)
            graphics.lineStyle(1, 0xffffff, 0.1);
            const gridSize = 100;
            for (let gx = -10; gx < 10; gx++) {
                for (let gy = -10; gy < 10; gy++) {
                    const worldX = gx * gridSize;
                    const worldY = gy * gridSize;
                    const screenPos = iso.toScreen(worldX, worldY);
                    const x = centerX + screenPos.x;
                    const y = centerY + screenPos.y;
                    
                    const tileSize = 50;
                    graphics.fillStyle(((gx + gy) % 2 === 0) ? 0x323246 : 0x1e1e32, 0.3);
                    graphics.beginPath();
                    graphics.moveTo(x, y);
                    graphics.lineTo(x + tileSize, y + tileSize * 0.5);
                    graphics.lineTo(x, y + tileSize);
                    graphics.lineTo(x - tileSize, y + tileSize * 0.5);
                    graphics.closePath();
                    graphics.fillPath();
                    graphics.strokePath();
                }
            }
            
            // ë Œë” ë¦¬ìŠ¤íŠ¸
            const renderList = [];
            
            // íŒŒí‹°í´
            game.particles.forEach(p => {
                const screenPos = iso.toScreen(p.x, p.y);
                renderList.push({
                    y: p.y,
                    render: () => {
                        const x = centerX + screenPos.x;
                        const y = centerY + screenPos.y - p.z * 0.5;
                        const colorNum = parseInt(p.color.replace('#', ''), 16);
                        graphics.fillStyle(colorNum, p.life / 30);
                        graphics.fillRect(x - p.size/2, y - p.size/2, p.size, p.size);
                    }
                });
            });
            
            // ë°œì‚¬ì²´ (ê¸€ë¡œìš° ê°•í™”)
            game.projectiles.forEach(proj => {
                const screenPos = iso.toScreen(proj.x, proj.y);
                renderList.push({
                    y: proj.y,
                    render: () => {
                        const x = centerX + screenPos.x;
                        const y = centerY + screenPos.y - (proj.z || 10) * 0.5;
                        const colorNum = parseInt(proj.color.replace('#', ''), 16);
                        
                        // ê¸€ë¡œìš°
                        graphics.fillStyle(colorNum, 0.3);
                        graphics.fillCircle(x, y, proj.size * 2.5);
                        
                        // ì½”ì–´
                        graphics.fillStyle(colorNum, 1);
                        graphics.fillCircle(x, y, proj.size);
                        
                        // í•˜ì´ë¼ì´íŠ¸
                        graphics.fillStyle(0xffffff, 0.6);
                        graphics.fillCircle(x, y, proj.size * 0.5);
                    }
                });
            });
            
            // ì  (ìœ¡ê°í˜• ëª¨ì–‘)
            game.enemies.forEach(enemy => {
                const screenPos = iso.toScreen(enemy.x, enemy.y);
                renderList.push({
                    y: enemy.y,
                    render: () => {
                        const x = centerX + screenPos.x;
                        const y = centerY + screenPos.y;
                        
                        // ê·¸ë¦¼ì
                        graphics.fillStyle(0x000000, 0.4);
                        graphics.fillEllipse(x, y + 5, 15, 8);
                        
                        // ì  (ìœ¡ê°í˜•)
                        graphics.lineStyle(3, 0xaa0000, 1);
                        graphics.fillStyle(0xff3333, 1);
                        graphics.beginPath();
                        for (let i = 0; i < 6; i++) {
                            const a = (Math.PI / 3) * i;
                            const px = x + Math.cos(a) * enemy.size;
                            const py = y - 5 + Math.sin(a) * enemy.size;
                            if (i === 0) graphics.moveTo(px, py);
                            else graphics.lineTo(px, py);
                        }
                        graphics.closePath();
                        graphics.fillPath();
                        graphics.strokePath();
                        
                        // HP ë°”
                        const hpBarWidth = 30;
                        const hpPercent = enemy.hp / enemy.maxHp;
                        graphics.fillStyle(0x333333, 1);
                        graphics.fillRect(x - hpBarWidth/2, y - enemy.size - 15, hpBarWidth, 3);
                        graphics.fillStyle(0xff0000, 1);
                        graphics.fillRect(x - hpBarWidth/2, y - enemy.size - 15, hpBarWidth * hpPercent, 3);
                    }
                });
            });
            
            // í”Œë ˆì´ì–´ (í–¥ìƒëœ ìš°ì£¼ì„ )
            renderList.push({
                y: 0,
                render: () => {
                    const x = centerX;
                    const y = centerY;
                    
                    // ê·¸ë¦¼ì
                    graphics.fillStyle(0x000000, 0.4);
                    graphics.fillEllipse(x, y + 8, 20, 10);
                    
                    // ì—”ì§„ ê¸€ë¡œìš°
                    graphics.fillStyle(0xff6600, 0.5);
                    graphics.fillCircle(x - 5, y + 5, 6);
                    graphics.fillCircle(x + 5, y + 5, 6);
                    
                    // ì„ ì²´
                    graphics.fillStyle(0x00ffff, 1);
                    graphics.lineStyle(2, 0x00aaaa, 1);
                    graphics.beginPath();
                    graphics.moveTo(x, y - 25);
                    graphics.lineTo(x - 15, y + 5);
                    graphics.lineTo(x, y);
                    graphics.lineTo(x + 15, y + 5);
                    graphics.closePath();
                    graphics.fillPath();
                    graphics.strokePath();
                    
                    // ì¡°ì¢…ì„
                    graphics.fillStyle(0x0088ff, 1);
                    graphics.fillRect(x - 5, y - 10, 10, 8);
                    
                    // ì—”ì§„
                    graphics.fillStyle(0xff6600, 1);
                    graphics.fillCircle(x - 5, y + 5, 3);
                    graphics.fillCircle(x + 5, y + 5, 3);
                    
                    // ê¸€ë¡œìš°
                    graphics.fillStyle(0x00ffff, 0.3);
                    graphics.fillCircle(x, y - 10, 25);
                    
                    // HP ë°”
                    const hpBarWidth = 40;
                    const hpPercent = game.player.hp / game.player.maxHp;
                    graphics.fillStyle(0x333333, 1);
                    graphics.fillRect(x - hpBarWidth/2, y - 35, hpBarWidth, 4);
                    graphics.fillStyle(hpPercent > 0.3 ? 0x00ff00 : 0xff0000, 1);
                    graphics.fillRect(x - hpBarWidth/2, y - 35, hpBarWidth * hpPercent, 4);
                }
            });
            
            // Y ì •ë ¬ í›„ ë Œë”
            renderList.sort((a, b) => a.y - b.y);
            renderList.forEach(obj => obj.render());
        }

        // ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ë“¤ (ì›ë˜ ë¡œì§)
        function spawnEnemy() {
            const angle = Math.random() * Math.PI * 2;
            const distance = 600;
            const x = Math.cos(angle) * distance;
            const y = Math.sin(angle) * distance;
            
            const difficulty = 1 + game.time / 60;
            
            game.enemies.push({
                x, y, size: 15,
                hp: 25 * difficulty,
                maxHp: 25 * difficulty,
                speed: 80 * Math.min(difficulty, 2),
                damage: 3,
                color: '#ff0000'
            });
        }
        
        function createParticles(x, y, z, color, count = 10) {
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 100 + 50;
                game.particles.push({
                    x, y, z: 10,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    vz: Math.random() * 30 + 10,
                    size: Math.random() * 4 + 2,
                    color,
                    life: 30
                });
            }
        }
        
        function showLevelUp() {
            game.paused = true;
            const modal = document.getElementById('levelUpModal');
            const options = document.getElementById('upgradeOptions');
            options.innerHTML = '';
            
            const available = Object.keys(weaponTypes).filter(k => {
                const w = weaponTypes[k];
                return !w.maxLevel || w.level < w.maxLevel;
            });
            
            const selected = [];
            while (selected.length < 5 && available.length > 0) {
                const idx = Math.floor(Math.random() * available.length);
                selected.push(available[idx]);
                available.splice(idx, 1);
            }
            
            selected.forEach(key => {
                const weapon = weaponTypes[key];
                const card = document.createElement('div');
                card.className = 'upgrade-card';
                card.innerHTML = `
                    <div class="upgrade-icon">${weapon.icon}</div>
                    <div class="upgrade-name">${weapon.name}</div>
                    <div class="upgrade-desc">${weapon.desc}</div>
                    <div class="level-display">Lv ${weapon.level} â†’ ${weapon.level + 1}</div>
                `;
                card.onclick = () => selectUpgrade(key);
                options.appendChild(card);
            });
            
            modal.style.display = 'block';
        }
        
        function selectUpgrade(key) {
            const weapon = weaponTypes[key];
            weapon.level++;
            
            if (weapon.shoot && !game.weapons.find(w => w.type === key)) {
                game.weapons.push({ type: key, lastShot: 0 });
            }
            
            if (weapon.apply) {
                weapon.apply();
            }
            
            document.getElementById('levelUpModal').style.display = 'none';
            game.paused = false;
        }
        
        function updateUI() {
            document.getElementById('hpText').textContent = `${Math.ceil(game.player.hp)}/${game.player.maxHp}`;
            document.getElementById('hpBar').style.width = (game.player.hp / game.player.maxHp * 100) + '%';
            document.getElementById('expText').textContent = `${game.player.exp}/${game.player.expToNext}`;
            document.getElementById('expBar').style.width = (game.player.exp / game.player.expToNext * 100) + '%';
            document.getElementById('levelText').textContent = game.player.level;
            document.getElementById('killText').textContent = game.kills;
            
            const minutes = Math.floor(game.time / 60);
            const seconds = Math.floor(game.time % 60);
            document.getElementById('timeText').textContent = 
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }
        
        function gameOver() {
            game.running = false;
            const minutes = Math.floor(game.time / 60);
            const seconds = Math.floor(game.time % 60);
            document.getElementById('finalTime').textContent = 
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            document.getElementById('finalKills').textContent = game.kills;
            document.getElementById('finalLevel').textContent = game.player.level;
            document.getElementById('gameOver').style.display = 'block';
        }
        
        window.addEventListener('resize', () => {
            phaserGame.scale.resize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>