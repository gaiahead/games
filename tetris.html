<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>TETRIS</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #0a0e1a;
    color: #e0e0e0;
    font-family: 'Courier New', monospace;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    overflow: hidden;
    user-select: none;
  }

  /* 배경 파티클 효과 */
  .bg { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; pointer-events: none; }

  .game-wrapper {
    display: flex;
    gap: 20px;
    align-items: flex-start;
    z-index: 1;
    position: relative;
  }

  /* 왼쪽 패널 */
  .side-panel {
    width: 140px;
    display: flex;
    flex-direction: column;
    gap: 16px;
  }

  .panel-box {
    background: rgba(20, 30, 50, 0.9);
    border: 1px solid #1e3a5f;
    border-radius: 10px;
    padding: 14px;
    box-shadow: 0 0 12px rgba(0, 100, 255, 0.08);
  }

  .panel-box h3 {
    font-size: 10px;
    text-transform: uppercase;
    letter-spacing: 2px;
    color: #4a8ab5;
    margin-bottom: 10px;
    border-bottom: 1px solid #1e3a5f;
    padding-bottom: 6px;
  }

  .panel-box .value {
    font-size: 24px;
    font-weight: bold;
    color: #fff;
    text-shadow: 0 0 8px rgba(100, 180, 255, 0.4);
  }

  .panel-box .sub-value {
    font-size: 11px;
    color: #6a8a9a;
    margin-top: 2px;
  }

  /* 메인 게임 영역 */
  .main-area {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 10px;
  }

  .title-bar {
    text-align: center;
    letter-spacing: 8px;
    font-size: 20px;
    font-weight: bold;
    color: #fff;
    text-shadow: 0 0 15px rgba(100, 180, 255, 0.6), 0 0 40px rgba(100, 180, 255, 0.2);
  }

  #gameCanvas {
    border: 2px solid #1e3a5f;
    border-radius: 6px;
    box-shadow: 0 0 25px rgba(0, 100, 255, 0.15), inset 0 0 30px rgba(0,0,0,0.5);
    background: #0d1220;
  }

  /* 오버라이 (시작/게임오버) */
  .overlay {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background: rgba(10, 14, 26, 0.85);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    border-radius: 6px;
    z-index: 10;
    backdrop-filter: blur(4px);
  }

  .overlay h2 {
    font-size: 28px;
    letter-spacing: 6px;
    color: #fff;
    text-shadow: 0 0 20px rgba(100, 180, 255, 0.7);
    margin-bottom: 12px;
  }

  .overlay .final-score {
    font-size: 16px;
    color: #4a8ab5;
    margin-bottom: 20px;
  }

  .overlay .hint {
    font-size: 13px;
    color: #6a8a9a;
    animation: pulse 1.8s ease-in-out infinite;
  }

  @keyframes pulse {
    0%, 100% { opacity: 0.5; }
    50% { opacity: 1; }
  }

  /* Next piece 캔버스 */
  #nextCanvas {
    display: block;
    margin: 0 auto;
  }

  /* 컨트롬 안내 */
  .controls {
    font-size: 10px;
    color: #4a6a7a;
    line-height: 1.8;
  }
  .controls span { color: #6ab0d0; }
</style>
</head>
<body>

<!-- 배경 파티클 캔버스 -->
<canvas class="bg" id="bgCanvas"></canvas>

<div class="game-wrapper">

  <!-- 왼쪽 패널 -->
  <div class="side-panel">
    <div class="panel-box">
      <h3>Score</h3>
      <div class="value" id="scoreVal">0</div>
      <div class="sub-value">HIGH: <span id="highVal">0</span></div>
    </div>
    <div class="panel-box">
      <h3>Lines</h3>
      <div class="value" id="linesVal">0</div>
    </div>
    <div class="panel-box">
      <h3>Level</h3>
      <div class="value" id="levelVal">1</div>
    </div>
    <div class="panel-box">
      <h3>Controls</h3>
      <div class="controls">
        <span>←→</span> 이동<br>
        <span>↑</span> 회전<br>
        <span>↓</span> 소프트드롭<br>
        <span>SPACE</span> 하드드롭
      </div>
    </div>
  </div>

  <!-- 메인 영역 -->
  <div class="main-area">
    <div class="title-bar">T E T R I S</div>
    <div style="position:relative;">
      <canvas id="gameCanvas" width="300" height="600"></canvas>
      <!-- 시작 오버라이 -->
      <div class="overlay" id="overlay">
        <h2>T E T R I S</h2>
        <div class="final-score" id="overlayScore"></div>
        <div class="hint">ENTER 키로 시작</div>
      </div>
    </div>
  </div>

  <!-- 오른쪽 패널 -->
  <div class="side-panel">
    <div class="panel-box">
      <h3>Next</h3>
      <canvas id="nextCanvas" width="112" height="112"></canvas>
    </div>
  </div>

</div>

<script>
// ============================================================
// TETRIS GAME ENGINE
// ============================================================

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const nextCanvas = document.getElementById('nextCanvas');
const nctx = nextCanvas.getContext('2d');
const overlay = document.getElementById('overlay');
const overlayScore = document.getElementById('overlayScore');
const bgCanvas = document.getElementById('bgCanvas');
const bgCtx = bgCanvas.getContext('2d');

// --- 상수 ---
const COLS = 10, ROWS = 20;
const BLOCK = 30; // 블록 크기 (px)
const TICK_BASE = 1000; // 기본 속도 (ms)

// --- 테트리스 블록 정의 (7종류) ---
// 각 블록은 회전 상태별 좌표 배열
const SHAPES = {
  I: { color: '#00f0f0', cells: [[[0,0],[1,0],[2,0],[3,0]], [[0,0],[0,1],[0,2],[0,3]], [[0,0],[1,0],[2,0],[3,0]], [[0,0],[0,1],[0,2],[0,3]]] },
  O: { color: '#f0f000', cells: [[[0,0],[1,0],[0,1],[1,1]]] },
  T: { color: '#a000f0', cells: [[[0,0],[1,0],[2,0],[1,1]], [[0,0],[0,1],[0,2],[1,1]], [[1,0],[0,1],[1,1],[2,1]], [[1,0],[1,1],[1,2],[0,1]]] },
  S: { color: '#00f000', cells: [[[1,0],[2,0],[0,1],[1,1]], [[0,0],[0,1],[1,1],[1,2]]] },
  Z: { color: '#f00000', cells: [[[0,0],[1,0],[1,1],[2,1]], [[1,0],[1,1],[0,1],[0,2]]] },
  J: { color: '#0000f0', cells: [[[0,0],[0,1],[1,1],[2,1]], [[0,0],[1,0],[0,1],[0,2]], [[0,0],[1,0],[2,0],[2,1]], [[1,0],[1,1],[1,2],[0,2]]] },
  L: { color: '#f0a000', cells: [[[2,0],[0,1],[1,1],[2,1]], [[0,0],[0,1],[0,2],[1,2]], [[0,0],[1,0],[2,0],[0,1]], [[1,0],[1,1],[1,2],[0,0]]] }
};
const SHAPE_KEYS = Object.keys(SHAPES);

// --- 점수 테이블 ---
const SCORE_TABLE = [0, 100, 300, 500, 800];

// --- 게임 상태 ---
let board, currentPiece, nextPiece, score, highScore, lines, level;
let gameState; // 'start', 'playing', 'gameover'
let tickInterval, lastTick;
let lockDelay = 0;

// --- 하이스코어 (localStorage) ---
function loadHighScore() {
  return parseInt(localStorage.getItem('tetris_high') || '0');
}
function saveHighScore(s) {
  localStorage.setItem('tetris_high', s.toString());
}

// ============================================================
// 초기화
// ============================================================
function init() {
  board = Array.from({ length: ROWS }, () => Array(COLS).fill(null));
  score = 0;
  lines = 0;
  level = 1;
  highScore = loadHighScore();
  gameState = 'start';
  currentPiece = null;
  nextPiece = spawnPiece();
  updateUI();
  drawOverlay(null);
  stopTick();
  render();
}

// ============================================================
// 블록 생성
// ============================================================
function spawnPiece() {
  const key = SHAPE_KEYS[Math.floor(Math.random() * SHAPE_KEYS.length)];
  const shape = SHAPES[key];
  return {
    key,
    color: shape.color,
    cells: shape.cells,
    rot: 0,
    x: Math.floor((COLS - 4) / 2), // 중앙 배치
    y: 0
  };
}

function getCells(piece) {
  const rot = piece.rot % piece.cells.length;
  return piece.cells[rot].map(([cx, cy]) => [piece.x + cx, piece.y + cy]);
}

// ============================================================
// 충돌 검사
// ============================================================
function isValid(piece, dx, dy, newRot) {
  const rot = (newRot !== undefined ? newRot : piece.rot) % piece.cells.length;
  const cells = piece.cells[rot];
  for (const [cx, cy] of cells) {
    const nx = piece.x + dx + cx;
    const ny = piece.y + dy + cy;
    if (nx < 0 || nx >= COLS || ny >= ROWS) return false;
    if (ny >= 0 && board[ny][nx]) return false;
  }
  return true;
}

// ============================================================
// 이동 / 회전
// ============================================================
function movePiece(dx, dy) {
  if (gameState !== 'playing') return;
  if (isValid(currentPiece, dx, dy)) {
    currentPiece.x += dx;
    currentPiece.y += dy;
    if (dy > 0) lockDelay = 0; // 아래로 이동하면 lock delay 초기화
  } else if (dy > 0) {
    // 아래로 이동 불가 → 블록 고정
    lockPiece();
  }
}

function rotatePiece() {
  if (gameState !== 'playing') return;
  const newRot = (currentPiece.rot + 1) % currentPiece.cells.length;
  // SRS-스타일 kick 시도
  const kicks = [[0,0],[1,0],[-1,0],[2,0],[-2,0]];
  for (const [kx, ky] of kicks) {
    if (isValid({ ...currentPiece, rot: newRot }, kx, ky)) {
      currentPiece.rot = newRot;
      currentPiece.x += kx;
      currentPiece.y += ky;
      return;
    }
  }
}

function hardDrop() {
  if (gameState !== 'playing') return;
  let drop = 0;
  while (isValid(currentPiece, 0, drop + 1)) drop++;
  currentPiece.y += drop;
  score += drop * 2; // 하드드롭 보너스
  lockPiece();
  playSound(440, 0.05, 'square');
}

// ============================================================
// 블록 고정 & 라인 클리어
// ============================================================
function lockPiece() {
  const cells = getCells(currentPiece);
  // 게임 오버 검사: 블록이 화면 밖
  for (const [cx, cy] of cells) {
    if (cy < 0) {
      gameOver();
      return;
    }
    board[cy][cx] = currentPiece.color;
  }
  playSound(260, 0.08, 'sine');

  // 라인 클리어
  const cleared = clearLines();
  if (cleared > 0) {
    score += SCORE_TABLE[cleared] * level;
    lines += cleared;
    // 레벨 업
    const newLevel = Math.floor(lines / 10) + 1;
    if (newLevel !== level) {
      level = newLevel;
      playSound(880, 0.15, 'sawtooth'); // 레벨 업 사운드
    }
    updateSpeed();
  }

  // 다음 블록
  currentPiece = nextPiece;
  nextPiece = spawnPiece();
  lockDelay = 0;

  // 새 블록도 유효하지 않으면 게임 오버
  if (!isValid(currentPiece, 0, 0)) {
    gameOver();
    return;
  }

  updateUI();
}

function clearLines() {
  let count = 0;
  for (let r = ROWS - 1; r >= 0; r--) {
    if (board[r].every(cell => cell !== null)) {
      board.splice(r, 1);
      board.unshift(Array(COLS).fill(null));
      count++;
      r++; // 같은 행 다시 검사
    }
  }
  if (count > 0) {
    // 라인 클리어 효과 사운드
    const freq = [0, 330, 440, 550, 880][count];
    playSound(freq, 0.12, 'triangle');
  }
  return count;
}

// ============================================================
// Ghost Piece (그림자)
// ============================================================
function getGhostY() {
  let ghostY = currentPiece.y;
  while (isValid(currentPiece, 0, ghostY - currentPiece.y + 1)) ghostY++;
  return ghostY;
}

// ============================================================
// 속도 관리
// ============================================================
function getTickSpeed() {
  // 레벨에 따라 속도 증가 (레벨 1: 1000ms, 레벨 10+: 100ms)
  return Math.max(100, TICK_BASE - (level - 1) * 100);
}

function updateSpeed() {
  stopTick();
  startTick();
}

function startTick() {
  const speed = getTickSpeed();
  tickInterval = setInterval(() => {
    if (gameState !== 'playing') return;
    movePiece(0, 1);
    render();
  }, speed);
}

function stopTick() {
  if (tickInterval) {
    clearInterval(tickInterval);
    tickInterval = null;
  }
}

// ============================================================
// 게임 시작 / 오버
// ============================================================
function startGame() {
  init();
  gameState = 'playing';
  overlay.style.display = 'none';
  currentPiece = nextPiece;
  nextPiece = spawnPiece();

  // 시작 블록이 유효한지 확인
  if (!isValid(currentPiece, 0, 0)) {
    gameOver();
    return;
  }
  updateUI();
  startTick();
  render();
}

function gameOver() {
  gameState = 'gameover';
  stopTick();
  if (score > highScore) {
    highScore = score;
    saveHighScore(highScore);
  }
  updateUI();
  drawOverlay('GAME OVER');
  // 게임 오버 사운드
  playSound(200, 0.3, 'sawtooth');
  setTimeout(() => playSound(150, 0.3, 'sawtooth'), 200);
  setTimeout(() => playSound(100, 0.4, 'sawtooth'), 400);
}

function drawOverlay(title) {
  overlay.style.display = 'flex';
  const h2 = overlay.querySelector('h2');
  h2.textContent = title || 'T E T R I S';
  if (title === 'GAME OVER') {
    overlayScore.textContent = `Final Score: ${score}`;
    overlay.querySelector('.hint').textContent = 'ENTER 키로 재시작';
  } else {
    overlayScore.textContent = '';
    overlay.querySelector('.hint').textContent = 'ENTER 키로 시작';
  }
}

// ============================================================
// UI 업데이트
// ============================================================
function updateUI() {
  document.getElementById('scoreVal').textContent = score;
  document.getElementById('highVal').textContent = highScore;
  document.getElementById('linesVal').textContent = lines;
  document.getElementById('levelVal').textContent = level;
}

// ============================================================
// 렌더링
// ============================================================
function render() {
  // 보드 배경 클리어
  ctx.fillStyle = '#0d1220';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // 그리드선 그리기
  ctx.strokeStyle = 'rgba(30, 58, 95, 0.4)';
  ctx.lineWidth = 0.5;
  for (let x = 0; x <= COLS; x++) {
    ctx.beginPath();
    ctx.moveTo(x * BLOCK, 0);
    ctx.lineTo(x * BLOCK, canvas.height);
    ctx.stroke();
  }
  for (let y = 0; y <= ROWS; y++) {
    ctx.beginPath();
    ctx.moveTo(0, y * BLOCK);
    ctx.lineTo(canvas.width, y * BLOCK);
    ctx.stroke();
  }

  // 고정된 블록 그리기
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      if (board[r][c]) {
        drawBlock(ctx, c, r, board[r][c]);
      }
    }
  }

  // Ghost piece 그리기
  if (currentPiece && gameState === 'playing') {
    const ghostY = getGhostY();
    const ghostPiece = { ...currentPiece, y: ghostY };
    const ghostCells = getCells(ghostPiece);
    for (const [gx, gy] of ghostCells) {
      if (gy >= 0) {
        ctx.fillStyle = 'rgba(255,255,255,0.08)';
        ctx.fillRect(gx * BLOCK + 1, gy * BLOCK + 1, BLOCK - 2, BLOCK - 2);
        ctx.strokeStyle = 'rgba(255,255,255,0.15)';
        ctx.lineWidth = 1;
        ctx.strokeRect(gx * BLOCK + 1, gy * BLOCK + 1, BLOCK - 2, BLOCK - 2);
      }
    }
  }

  // 현재 블록 그리기
  if (currentPiece && gameState === 'playing') {
    const cells = getCells(currentPiece);
    for (const [cx, cy] of cells) {
      if (cy >= 0) {
        drawBlock(ctx, cx, cy, currentPiece.color);
      }
    }
  }

  // Next piece 렌더링
  renderNext();
}

function drawBlock(context, x, y, color) {
  const px = x * BLOCK;
  const py = y * BLOCK;
  const s = BLOCK;

  // 블록 본체
  context.fillStyle = color;
  context.fillRect(px + 1, py + 1, s - 2, s - 2);

  // 밝은 테두리 (위, 왼쪽) — 3D 효과
  context.fillStyle = lighten(color, 0.35);
  context.fillRect(px + 1, py + 1, s - 2, 3); // 위
  context.fillRect(px + 1, py + 1, 3, s - 2); // 왼쪽

  // 어두운 테두리 (아래, 오른쪽)
  context.fillStyle = darken(color, 0.35);
  context.fillRect(px + 1, py + s - 4, s - 2, 3); // 아래
  context.fillRect(px + s - 4, py + 1, 3, s - 2); // 오른쪽

  // 가장 밝은 중앙 하이라이트
  context.fillStyle = lighten(color, 0.15);
  context.fillRect(px + 4, py + 4, s - 8, s - 8);
}

function renderNext() {
  nctx.fillStyle = '#0d1220';
  nctx.fillRect(0, 0, nextCanvas.width, nextCanvas.height);

  if (!nextPiece) return;

  const cells = nextPiece.cells[0];
  // 블록 중앙 정렬 계산
  let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
  for (const [cx, cy] of cells) {
    minX = Math.min(minX, cx); maxX = Math.max(maxX, cx);
    minY = Math.min(minY, cy); maxY = Math.max(maxY, cy);
  }
  const w = maxX - minX + 1;
  const h = maxY - minY + 1;
  const cellSize = 24;
  const offsetX = (nextCanvas.width - w * cellSize) / 2 - minX * cellSize;
  const offsetY = (nextCanvas.height - h * cellSize) / 2 - minY * cellSize;

  for (const [cx, cy] of cells) {
    const px = offsetX + cx * cellSize;
    const py = offsetY + cy * cellSize;

    nctx.fillStyle = nextPiece.color;
    nctx.fillRect(px + 1, py + 1, cellSize - 2, cellSize - 2);

    nctx.fillStyle = lighten(nextPiece.color, 0.35);
    nctx.fillRect(px + 1, py + 1, cellSize - 2, 2);
    nctx.fillRect(px + 1, py + 1, 2, cellSize - 2);

    nctx.fillStyle = darken(nextPiece.color, 0.35);
    nctx.fillRect(px + 1, py + cellSize - 3, cellSize - 2, 2);
    nctx.fillRect(px + cellSize - 3, py + 1, 2, cellSize - 2);
  }
}

// ============================================================
// 색상 헬퍼
// ============================================================
function hexToRgb(hex) {
  const r = parseInt(hex.slice(1, 3), 16);
  const g = parseInt(hex.slice(3, 5), 16);
  const b = parseInt(hex.slice(5, 7), 16);
  return [r, g, b];
}

function lighten(hex, amount) {
  const [r, g, b] = hexToRgb(hex);
  return `rgb(${Math.min(255, r + 255 * amount)},${Math.min(255, g + 255 * amount)},${Math.min(255, b + 255 * amount)})`;
}

function darken(hex, amount) {
  const [r, g, b] = hexToRgb(hex);
  return `rgb(${Math.max(0, r * (1 - amount))},${Math.max(0, g * (1 - amount))},${Math.max(0, b * (1 - amount))})`;
}

// ============================================================
// Web Audio API — 간단한 사운드 효과
// ============================================================
let audioCtx = null;
function getAudioCtx() {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  return audioCtx;
}

function playSound(freq, duration, type = 'sine') {
  try {
    const ac = getAudioCtx();
    const osc = ac.createOscillator();
    const gain = ac.createGain();
    osc.type = type;
    osc.frequency.setValueAtTime(freq, ac.currentTime);
    gain.gain.setValueAtTime(0.15, ac.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, ac.currentTime + duration);
    osc.connect(gain);
    gain.connect(ac.destination);
    osc.start();
    osc.stop(ac.currentTime + duration);
  } catch (e) { /* 사운드 실패 무시 */ }
}

// ============================================================
// 배경 파티클 효과
// ============================================================
const particles = [];
function initBg() {
  bgCanvas.width = window.innerWidth;
  bgCanvas.height = window.innerHeight;
  for (let i = 0; i < 60; i++) {
    particles.push({
      x: Math.random() * bgCanvas.width,
      y: Math.random() * bgCanvas.height,
      size: Math.random() * 2 + 0.5,
      speedY: Math.random() * 0.3 + 0.1,
      alpha: Math.random() * 0.4 + 0.1
    });
  }
}

function animateBg() {
  bgCtx.clearRect(0, 0, bgCanvas.width, bgCanvas.height);
  for (const p of particles) {
    bgCtx.fillStyle = `rgba(80, 140, 200, ${p.alpha})`;
    bgCtx.beginPath();
    bgCtx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
    bgCtx.fill();
    p.y += p.speedY;
    if (p.y > bgCanvas.height) {
      p.y = 0;
      p.x = Math.random() * bgCanvas.width;
    }
  }
  requestAnimationFrame(animateBg);
}

window.addEventListener('resize', () => {
  bgCanvas.width = window.innerWidth;
  bgCanvas.height = window.innerHeight;
});

// ============================================================
// 키보드 입력
// ============================================================
document.addEventListener('keydown', (e) => {
  if (e.key === 'Enter') {
    if (gameState === 'start' || gameState === 'gameover') {
      startGame();
    }
    return;
  }
  if (gameState !== 'playing') return;

  switch (e.key) {
    case 'ArrowLeft':  e.preventDefault(); movePiece(-1, 0); break;
    case 'ArrowRight': e.preventDefault(); movePiece(1, 0);  break;
    case 'ArrowDown':  e.preventDefault(); movePiece(0, 1);  score += 1; updateUI(); break;
    case 'ArrowUp':    e.preventDefault(); rotatePiece();     break;
    case ' ':          e.preventDefault(); hardDrop();        break;
  }
  render();
});

// ============================================================
// 모바일 터치 컨트롤 (선택적)
// ============================================================
let touchStartX = 0, touchStartY = 0;
document.addEventListener('touchstart', (e) => {
  touchStartX = e.touches[0].clientX;
  touchStartY = e.touches[0].clientY;
}, { passive: true });

document.addEventListener('touchend', (e) => {
  if (gameState === 'start' || gameState === 'gameover') {
    startGame();
    return;
  }
  const dx = e.changedTouches[0].clientX - touchStartX;
  const dy = e.changedTouches[0].clientY - touchStartY;
  const adx = Math.abs(dx), ady = Math.abs(dy);
  if (adx < 10 && ady < 10) { rotatePiece(); }
  else if (adx > ady) { movePiece(dx > 0 ? 1 : -1, 0); }
  else { if (dy > 0) hardDrop(); else rotatePiece(); }
  render();
}, { passive: true });

// ============================================================
// 시작!
// ============================================================
initBg();
animateBg();
init();
</script>
</body>
</html>
